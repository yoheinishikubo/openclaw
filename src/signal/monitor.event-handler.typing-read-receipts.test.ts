import { beforeEach, describe, expect, it, vi } from "vitest";
import {
  createBaseSignalEventHandlerDeps,
  createSignalReceiveEvent,
} from "./monitor/event-handler.test-harness.js";

const sendTypingMock = vi.fn();
const sendReadReceiptMock = vi.fn();
const dispatchInboundMessageMock = vi.fn(
  async (params: {
    replyOptions?: { onReplyStart?: () => void };
    dispatcher?: { sendFinalReply?: (payload: { text: string }) => void };
  }) => {
    await Promise.resolve(params.replyOptions?.onReplyStart?.());
    return { queuedFinal: false, counts: { tool: 0, block: 0, final: 0 } };
  },
);

vi.mock("./send.js", () => ({
  sendMessageSignal: vi.fn(),
  sendTypingSignal: sendTypingMock,
  sendReadReceiptSignal: sendReadReceiptMock,
}));

vi.mock("../auto-reply/dispatch.js", () => ({
  dispatchInboundMessage: dispatchInboundMessageMock,
  dispatchInboundMessageWithDispatcher: dispatchInboundMessageMock,
  dispatchInboundMessageWithBufferedDispatcher: dispatchInboundMessageMock,
}));

vi.mock("../pairing/pairing-store.js", () => ({
  readChannelAllowFromStore: vi.fn().mockResolvedValue([]),
  upsertChannelPairingRequest: vi.fn(),
}));

describe("signal event handler typing + read receipts", () => {
  beforeEach(() => {
    vi.useRealTimers();
    sendTypingMock.mockClear().mockResolvedValue(true);
    sendReadReceiptMock.mockClear().mockResolvedValue(true);
    dispatchInboundMessageMock.mockClear();
  });

  it("sends typing + read receipt for allowed DMs", async () => {
    const { createSignalEventHandler } = await import("./monitor/event-handler.js");
    const handler = createSignalEventHandler(
      createBaseSignalEventHandlerDeps({
        cfg: {
          messages: { inbound: { debounceMs: 0 } },
          channels: { signal: { dmPolicy: "open", allowFrom: ["*"] } },
        },
        account: "+15550009999",
        blockStreaming: false,
        historyLimit: 0,
        groupHistories: new Map(),
        sendReadReceipts: true,
      }),
    );

    await handler(
      createSignalReceiveEvent({
        dataMessage: {
          message: "hi",
        },
      }),
    );

    expect(sendTypingMock).toHaveBeenCalledWith("+15550001111", expect.any(Object));
    expect(sendReadReceiptMock).toHaveBeenCalledWith(
      "signal:+15550001111",
      1700000000000,
      expect.any(Object),
    );
  });

  it("prefixes group bodies with sender label", async () => {
    let capturedBody = "";
    dispatchInboundMessageMock.mockImplementationOnce(
      async (params: { dispatcher?: { sendFinalReply?: (payload: { text: string }) => void } }) => {
        const ctx = params as { ctx?: { Body?: string } };
        capturedBody = ctx.ctx?.Body ?? "";
        params.dispatcher?.sendFinalReply?.({ text: "ok" });
        return { queuedFinal: true, counts: { tool: 0, block: 0, final: 1 } };
      },
    );

    const { createSignalEventHandler } = await import("./monitor/event-handler.js");
    const handler = createSignalEventHandler(
      createBaseSignalEventHandlerDeps({
        cfg: {
          channels: { signal: {} },
        } as never,
        account: "+15550009999",
        blockStreaming: false,
        historyLimit: 0,
        groupHistories: new Map(),
        allowFrom: [],
        groupAllowFrom: [],
        sendReadReceipts: false,
      }),
    );

    await handler(
      createSignalReceiveEvent({
        dataMessage: {
          message: "hello",
          groupInfo: { groupId: "group-1", groupName: "Test Group" },
        },
      }),
    );

    expect(dispatchInboundMessageMock).toHaveBeenCalled();
    expect(capturedBody).toContain("Alice (+15550001111): hello");
  });
});
